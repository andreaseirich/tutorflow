# =====================================================================
# MASTER PROMPT – PROJEKT "TUTORFLOW"
# Verbindliche Regeln für Cursor AI (inkl. Cursor AI Agent)
# =====================================================================

# WICHTIG: NUTZUNG
# Jede Aufgabe an Cursor MUSS mit folgender Anweisung beginnen:
# "Lies zuerst den Master Prompt (diese Datei), halte dich strikt daran."
# Cursor MUSS diese Datei vollständig lesen, bevor es:
# - Architekturentscheidungen trifft
# - Code generiert oder ändert
# - Dokumentation anfasst
# - Git-Commits erzeugt

# =====================================================================
# 1) PROJEKTIDENTITÄT
# =====================================================================

projekt_name: "TutorFlow"

beschreibung: >
  TutorFlow ist eine Web-Anwendung für Nachhilfelehrer.
  Sie ermöglicht:
  - Verwaltung von Schülern, Verträgen und Nachhilfestunden
  - Planung mit Blockzeiten und Fahrtzeiten
  - Auswertung von Einnahmen nach Monaten / Status
  - optional: Hochladen von Auftragsbestätigungen (PDF) zur Datenextraktion
  - Premium-Funktion: KI-gestützte Generierung von Unterrichtsplänen
    mithilfe einer LLM-API (z. B. ChatGPT)

ziel: >
  Ein funktionsfähiges, gut dokumentiertes MVP für den Teca-Hacks-Hackathon,
  das technisch sauber, übersichtlich strukturiert und ethisch verantwortbar ist.


# =====================================================================
# 2) ETHISCH-CHRISTLICHER RAHMEN
# =====================================================================

ethik:
  grundsätze:
    - Ehrlichkeit, Transparenz, kein Datenmissbrauch
    - Ordnung, Klarheit, Nachvollziehbarkeit
    - Dienst am Nutzer: das Werkzeug soll ihm helfen, strukturierter und verantwortungsvoller zu arbeiten
    - Keine versteckten Funktionen, keine manipulative Logik
    - Respektvoller Umgang mit Sprache und Benutzerdaten
  biblischer_bezug:
    - Der Stil der Software soll von Ordnung und Zuverlässigkeit geprägt sein
    - Keine theologischen Aussagen im Code erzwingen, aber Werte wie Treue, Klarheit und Verantwortlichkeit widerspiegeln


# =====================================================================
# 3) HACKATHON-KONFORMITÄT (TECA HACKS)
# =====================================================================

hackathon_regeln:
  - Alle Arbeiten (Code, Architektur, Doku) müssen während des Hackathons neu entstehen.
  - Kein Kopieren kompletter Projekte oder größerer Codeblöcke aus fremden Repositories.
  - Open-Source-Bibliotheken dürfen verwendet werden, müssen aber im README genannt werden.
  - AI-Tools (Cursor, ChatGPT, etc.) sind erlaubt, aber es muss eine sinnvolle menschliche
    Beteiligung geben (Entscheidungen, Architektur, Kontrolle).
  - Keine Verletzung von Urheberrecht oder geistigem Eigentum.
  - Kein verbotener oder unangemessener Content.


# =====================================================================
# 4) TECHNOLOGIE-STACK
# =====================================================================

tech_stack:
  backend:
    framework: "Django"
    version: "aktuellste stabile Version (z. B. 5.x; genau in requirements festhalten)"
  frontend:
    vorgaben: >
      Frei wählbar (z. B. Django-Templates, HTMX, Tailwind, React),
      aber so einfach wie möglich für das MVP.
  datenbank:
    vorgabe: >
      Entwicklung standardmäßig mit SQLite, optionale Vorbereitung für PostgreSQL.
  sonstiges:
    - Verwendung moderner Django-Best-Practices
    - Keine exotischen oder experimentellen Libraries ohne triftigen Grund


# =====================================================================
# 5) ARCHITEKTUR-STANDARDS & DATEISTRUKTUR
# =====================================================================

architektur:
  ordnerstruktur_grundsatz: >
    Das Repository soll klar in Backend, Frontend (falls separat),
    Dokumentation (docs/) und Hilfsskripte gegliedert sein.

  beispiel_ordner:
    - backend/ (Django-Projekt + Apps)
    - backend/config/ (Projektkonfiguration)
    - backend/apps/ (Feature-spezifische Apps, z. B. students/, contracts/, scheduling/, billing/)
    - docs/ (ARCHITECTURE.md, ETHICS.md, API.md, PHASES.md etc.)
    - scripts/ (Validierung, Tests, Hilfstools)

  module_trennung: >
    Code-Dateien sollen KURZ und FOKUSSIERT sein.
    - Eine einzelne Python-Datei sollte nach Möglichkeit nicht mehr als ca. 300–400 Zeilen haben.
    - Wenn eine Datei größer zu werden droht:
      -> Cursor muss aktiv vorschlagen, den Code auf mehrere Module aufzuteilen.
      -> Z. B. services.py, selectors.py, validators.py, etc.
    - Keine "God-Modules" mit zu vielen Verantwortlichkeiten.

  naming_conventions:
    - snake_case für Python-Funktionen und -Variablen
    - PascalCase für Klassen
    - sprechende Namen, keine Abkürzungs-Ungetüme
    - Django-Apps nach Domain benennen (students, contracts, lessons, billing, core)

  logging_und_error_handling:
    - Gezielt und sparsam loggen
    - Keine stummen Fehler
    - Fehler möglichst früh validieren (z. B. Form-/Serializer-Validierung)


# =====================================================================
# 6) DOMAIN-MODEL (INHALTLICH, NICHT KODIERT)
# =====================================================================

domain_entitäten:
  - Student: Name, Kontaktdaten, Schule/Klasse, Fächer, Standard-Unterrichtsort
  - Contract: Student, Institut, Honorar pro Einheit, Dauer einer Einheit, Vertragszeitraum,
              evtl. geplante Einheiten/Monat
  - Lesson: Datum, Startzeit, Dauer, Status (geplant/unterrichtet/ausgefallen/ausgezahlt),
            Ort, Fahrtzeit vorher/nachher
  - BlockedTime: Eigene Termine/Blockzeiten (z. B. Uni, Job, Gemeinde)
  - Location: Name, Adresse, optional Koordinaten
  - LessonPlan: KI-generierter Unterrichtsplan (Text + Metadaten)
  - User: Django-User mit Zusatzfeld für Premium-Status
  - IncomeOverview: Abgeleitete Monats-/Jahresauswertungen

Cursor darf diese Modelle technisch verfeinern oder umstrukturieren,
aber die Semantik muss erhalten bleiben.


# =====================================================================
# 7) MASTER PROMPT, DOKUMENTATION & SINGLE SOURCE OF TRUTH
# =====================================================================

master_prompt_und_doku:
  master_prompt_datei: >
    Diese Datei (Master Prompt) liegt im Repo und wird als Quelle aller
    Architektur- und Verhaltensregeln verwendet.

  dokumentationspflichten:
    - README.md:
        - Projektbeschreibung, Problem, Lösung, Features, Tech Stack, Setup, Beispiele
    - docs/ARCHITECTURE.md:
        - Überblick über Schichten, Apps, Datenmodelle, Flows
    - docs/ETHICS.md:
        - Kurzbeschreibung der ethisch-christlichen Leitlinien und Datenschutzprinzipien
    - docs/CHANGELOG.md:
        - Jede relevante Änderung mit Datum, Version, kurzer Beschreibung
    - optional: docs/PHASES.md:
        - Übersicht über Phasen, Status, Checkpoints

  verhalten_cursor:
    - Bei JEDER relevanten Code-Änderung:
      - prüfen: Müssen README, ARCHITECTURE.md, ETHICS.md, CHANGELOG aktualisiert werden?
      - falls ja: aktualisieren, mit Datum/Zeiten versehen.
    - Keine stillen Abweichungen von diesen Regeln.


# =====================================================================
# 8) ARBEIT IN PHASEN
# =====================================================================

phasen:
  - name: "Phase 1 – Projekt-Setup & Architekturgrundlagen"
    ziel: >
      Repository initialisieren, Django-Grundprojekt anlegen,
      erste App-Struktur definieren, Grunddokumentation schreiben.
    akzeptanzkriterien:
      - Django-Projekt lauffähig
      - Basis-Ordnerstruktur vorhanden
      - README, ARCHITECTURE, ETHICS, CHANGELOG angelegt und befüllt
    tests:
      - Start des Dev-Servers
      - mind. 1 einfacher Smoke-Test

  - name: "Phase 2 – Domain-Datenmodell & Migrations"
    ziel: >
      Zentrale Models (Student, Contract, Lesson, BlockedTime, Location, User-Erweiterung)
      definieren und migrieren.
    akzeptanzkriterien:
      - Alle Models definiert, Migrationen laufen
      - ARCHITECTURE.md und ggf. API/Datenmodell-Doku aktualisiert
    tests:
      - einfache Unit-Tests für Model-Logik (z. B. Berechnung von Honoraren)

  - name: "Phase 3 – Kernfunktionen (Planung & Einnahmen)"
    ziel: >
      CRUD für Schüler, Verträge, Lessons, Blockzeiten;
      Monatsansicht + Einnahmenberechnungen;
      einfache Konfliktprüfung.
    akzeptanzkriterien:
      - Oberfläche/Endpoints zur Verwaltung
      - Einkommensberechnung pro Monat
      - Konfliktprüfung funktioniert in einfachen Szenarien
    tests:
      - Tests für Planungslogik und Summenberechnung

  - name: "Phase 4 – Premium & KI-Funktionen"
    ziel: >
      Premium-Flag am User, Integration einer LLM-API für Unterrichtsplan-Erstellung,
      saubere Trennung von Basis- und Premium-Features.
    akzeptanzkriterien:
      - KI-Unterrichtsplan kann für Premium-User erzeugt werden
      - ETHICS.md enthält Hinweise zum KI-Einsatz
    tests:
      - Mock-Tests/Integrationstests für KI-Aufrufe

  - name: "Phase 5 – Polishing, Validierung & Hackathon-Feinschliff"
    ziel: >
      UI verbessern, Demo-Daten einpflegen, Doku finalisieren, Tests stabilisieren,
      alles auf Hackathon-Submission trimmen.
    akzeptanzkriterien:
      - Vollständig laufendes System
      - Aktuelle Dokumentation
      - Klare Demo-Story


# =====================================================================
# 9) CHECKPOINT-SYSTEM & VALIDIERUNG
# =====================================================================

checkpoints:
  dateien:
    - docs/CHECKPOINTS.md (oder ähnlich)
  inhalt:
    - Aktuelle Phase
    - Kurze Zusammenfassung, was fertig ist
    - Offene ToDos

konsistenz_prüfung:
  cursor_muss:
    - vor Abschluss einer Phase:
      - alle relevanten Dateien öffnen
      - auf Inkonsistenzen prüfen (z. B. ARCHITECTURE.md vs. Code)
      - fehlende Doku ergänzen
      - Tests/Validierungsskripte laufen lassen

validierungsskripte:
  beispiele:
    - Linter/Formatter
    - Testsuite (pytest/django test)
    - Skript, das prüft:
        - Sind Doku-Dateien aktualisiert?
        - Stimmen Zeitstempel und Versionen im CHANGELOG?
        - Entsprechen Models der Dokumentation?

zeitzone_und_datumsregeln:
  - Cursor MUSS für alle Dateierstellungen, Dokumentation, Zeitstempel,
    Log-Einträge und generierten Inhalte die Zeitzone **Europe/Berlin**
    verwenden.
  - Alle Datumsangaben sollen im ISO-Format YYYY-MM-DD dokumentiert werden.
  - Cursor DARF keine anderen Zeitzonen oder automatisch berechneten UTC-Zeiten
    verwenden.
  - Cursor MUSS die Systemlogik der Anwendung so konfigurieren, dass Django
    und alle zugehörigen Komponenten in der Zeitzone Europe/Berlin laufen.
  - Cursor MUSS in der Dokumentation (PHASES.md, CHECKPOINTS.md, CHANGELOG.md)
    rückwirkend alle falschen Datumsangaben erkennen und auf Europe/Berlin
    korrekt anpassen.
  - Wenn ein Datum aus dem Kontext unklar ist oder nicht exakt rekonstruierbar:
        → Cursor soll ein Platzhalterdatum setzen und darauf hinweisen.
  - Diese Zeitzonenregel ist dauerhaft und gilt für alle zukünftigen Phasen.
  - Wenn Datumsangaben bereits existieren und offensichtlich nicht mit der realen Projektzeit übereinstimmen 
  (z. B. liegen sie deutlich in der Zukunft oder vor Projektstart), dann muss Cursor das als Fehler behandeln:
    * entweder den Nutzer nach dem korrekten Datum fragen
    * oder – falls der Nutzer explizit ein Ziel-Datum vorgibt – alle betroffenen Stellen konsistent korrigieren.

Cursor muss solche Skripte erzeugen und regelmäßig ausführen,
insbesondere vor Commits, Phasenwechseln und vor Hackathon-Submission.


# =====================================================================
# 10) TYPISCHE SCHWIERIGKEITEN & SCHUTZMECHANISMEN
# =====================================================================

probleme_und_lösungen:
  - problem: "Cursor vergisst den Master Prompt"
    lösung: >
      Jede Aufgabe beginnt mit:
      "Verwende zuerst den Master Prompt. Lies ihn vollständig und befolge ihn streng."

  - problem: "Cursor aktualisiert Doku nicht"
    lösung: >
      Cursor MUSS vor/bei jeder relevanten Änderung prüfen, ob README,
      ARCHITECTURE, ETHICS, CHANGELOG angepasst werden müssen.

  - problem: "Cursor halluziniert Dateiinhalte"
    lösung: >
      Cursor MUSS jede Datei, die er ändern will, zuerst öffnen und
      auf Basis des IST-Zustands ändern – keine Annahmen.

  - problem: "Konflikte zwischen mehreren Repositories"
    lösung: >
      Falls mehrere Repos existieren (z. B. server, client, docs),
      Cursor MUSS bei Tasks prüfen, ob alle Repos synchron und konsistent sind.

  - problem: "Cursor macht Änderungen ohne Git-Commits"
    lösung: >
      Jede relevante Änderung MUSS in einem Commit landen.
      Commit-Messages sollen kurz aber aussagekräftig sein (z. B. feat:, fix:, docs:, chore:).


# =====================================================================
# 11) ALLGEMEINE REGELN FÜR DIE ZUSAMMENARBEIT MIT CURSOR
# =====================================================================

allgemeine_regeln:
  - 1: Immer zuerst den Master Prompt lesen.
  - 2: Vor jeder Änderung die realen Dateien öffnen (kein Raten).
  - 3: Dokumentation synchron halten (README, ARCHITECTURE, ETHICS, CHANGELOG).
  - 4: Validierungs-Skripte regelmäßig ausführen.
  - 5: Alle Änderungen in Git-Commits verpacken, klare Messages.
  - 6: Phasen vollständig abschließen, bevor die nächste begonnen wird.
  - 7: Keine Codegenerierung ohne sinnvolle Tests (mind. Basistests).
  - 8: Keine Annahmen über Dateiinhalte; immer zuerst lesen.
  - 9: Keine Überschreibungen ohne Konsistenzprüfung.
  - 10: Fortschritt und Phasenstatus protokollieren (CHECKPOINTS).
  - 11: Zeitstempel und Versions-/Phasenangaben pflegen.
  - 12: Fehler offen melden, nicht still weitermachen; lieber stoppen und nachfragen.

# =====================================================================
# ENDE DES MASTER PROMPTS
# =====================================================================
